{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sidey",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Simple and minimalistic jekyll blogging theme.",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2024/05/05/unpacking-observable-and-appstorage-part-2",
            "title": "@Observable vs @AppStorage Conflict: Part 2",
            "summary": "Explore the intricate relationship between @Observable and @AppStorage in SwiftUI in this detailed guide. Learn what triggers conflicts between these two features and gain insights into their operational mechanisms. Perfect for developers looking to deepen their understanding of SwiftUI's architecture and improve their coding practices",
            "content_text": "In the previous article, we explored the conflict that arises when combining @Observable and @AppStorage. This follow-up provides a solution grounded in an understanding observation, identity, and the distinctions between reference and structural semantics.Important Background: Reference and Structural Semantics      Reference Semantics: refers to objects where multiple variables can refer to the same instance in memory. Any changes made through one reference affect the underlying object and, consequently, all other references to it.          Tip: Think of reference types (e.g., classes, functions) when considering reference semantics - there are are allocated in shared memory spaces and accessed via pointers.            Structural Semantics: in contrast, this pertains to objects where variables hold independent copies of data. Modifications to one variable do not impact others.          Value types (e.g., structs, enums, tuples) are examples of structural semantics, emphasizing independent data handling      Conflict Overview@Observable converts all stored properties in a class to computed properties to enable detailed observation, leveraging reference semantics for unique change tracking. Conversely, @AppStorage is a property wrapper for direct interaction with UserDefaults, relying on its own getter and setter methods and typically aligning with structural semantics.The SolutionThe key to resolving the conflict lies in ensuring that @AppStorage adheres to reference semantics when used within an @Observable class: The design details section of the original pitch provides guidance:  Observation of an entity implies that entity has identity. That means that things that are observable are inherently reference types. Structural types that are not rooted in a reference semantic storage do not have a well formed concept of external observation of changes. However, if the structure is a member variable of a reference type, descendant key paths to specific values passing through structural types with a root of a reference type do make sense as being an observable field.To implement a solution alighed with these principles, first move properties annotated with @AppStorage into  a reference type:class Storage {    @AppStorage(\"name\") public var name = \"johnDoe\"    @AppStorage(\"age\") public var age = 12        init() {}}Next the reference type, Storage is integrated into an observable class (UserSettings) and made a member variable of said class:import SwiftUI@Observable class UserSettings {    class Storage {        @AppStorage(\"name\") public var name = \"johnDoe\"        @AppStorage(\"age\") public var age = 12                init() {}    }        private let storage = Storage()}Finally the property observer didSet is added for each variable we want to observe and update:import SwiftUI@Observable class UserSettings {    class Storage {        @AppStorage(\"name\") public var name = \"johnDoe\"        @AppStorage(\"age\") public var age = 12                init() {}    }        private let storage = Storage()        public var name: String {      didSet {        storage.name = name      }    }        public var age: Int {      didSet {        storage.age = age      }    }}Code Breakdown:Each property in UserSettings is backed by a corresponding property in the Storage class.      Direct Access and Persistence: when a property (e.g. name) in UserSettings is set, its didSet observe updates the corresponding value in the Storage instance, which immediately saves it in UserDefaults via the AppStorage wrapper.        Initialization and Synchronization: when UserSettings is initialized, it sets its properties from the corresponding values in Stroage, which reads these values from UserDefaults. This ensures that a user’s settings are populated with the previously saved values when the app starts. With @AppStorage properties encapsulated in a distinct reference type (Storage), UserSettings is able to indirectly access  @AppStorage properties through Storage, enabling observation via @Observable while avoiding direct application of @AppStorage.  This approch effectively organizes data handling and observing changes in UserSettings by leveraging the strengths of both @AppStorage for persistent storage and @Observable for observing and responding to changes.",
            "content_html": "<p>In the previous article, we explored the conflict that arises when combining @Observable and @AppStorage. This follow-up provides a solution grounded in an understanding observation, identity, and the distinctions between reference and structural semantics.</p><h2 id=\"important-background-reference-and-structural-semantics\"><u>Important Background: Reference and Structural Semantics</u></h2><ul>  <li>    <p><strong>Reference Semantics</strong>: refers to objects where multiple variables can refer to the same instance in memory. Any changes made through one reference affect the underlying object and, consequently, all other references to it.</p>    <blockquote>      <p><strong>Tip</strong>: Think of reference types (e.g., classes, functions) when considering reference semantics - there are are allocated in shared memory spaces and accessed via pointers.</p>    </blockquote>  </li>  <li>    <p>Structural Semantics: in contrast, this pertains to objects where variables hold independent copies of data. Modifications to one variable do not impact others.</p>    <blockquote>      <p>Value types (e.g., structs, enums, tuples) are examples of structural semantics, emphasizing independent data handling</p>    </blockquote>  </li></ul><h2 id=\"conflict-overview\"><u>Conflict Overview</u></h2><p><strong>@Observable</strong> converts all stored properties in a class to computed properties to enable detailed observation, leveraging reference semantics for unique change tracking. Conversely, <strong>@AppStorage</strong> is a property wrapper for direct interaction with UserDefaults, relying on its own getter and setter methods and typically aligning with structural semantics.</p><h2 id=\"the-solution\"><u>The Solution</u></h2><p>The key to resolving the conflict lies in ensuring that <strong>@AppStorage</strong> adheres to reference semantics when used within an @Observable class: The <a href=\"https://forums.swift.org/t/pitch-observation/62051#detailed-design-8\">design details section of the original pitch</a> provides guidance:</p><blockquote>  <p>Observation of an entity implies that entity has identity. That means that things that are observable are inherently reference types. Structural types that are not rooted in a reference semantic storage do not have a well formed concept of external observation of changes. However, if the structure is a member variable of a reference type, descendant key paths to specific values passing through structural types with a root of a reference type do make sense as being an observable field.</p></blockquote><p>To implement a solution alighed with these principles, first move properties annotated with <strong>@AppStorage</strong> into  a reference type:</p><div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">Storage</span> <span class=\"p\">{</span>    <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"name\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"johnDoe\"</span>    <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"age\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">age</span> <span class=\"o\">=</span> <span class=\"mi\">12</span>        <span class=\"nf\">init</span><span class=\"p\">()</span> <span class=\"p\">{}</span><span class=\"p\">}</span></code></pre></div></div><p>Next the reference type, <code class=\"language-plaintext highlighter-rouge\">Storage</code> is integrated into an observable class (<code class=\"language-plaintext highlighter-rouge\">UserSettings</code>) and made a member variable of said class:</p><div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">import</span> <span class=\"kt\">SwiftUI</span><span class=\"kd\">@Observable</span> <span class=\"kd\">class</span> <span class=\"kt\">UserSettings</span> <span class=\"p\">{</span>    <span class=\"kd\">class</span> <span class=\"kt\">Storage</span> <span class=\"p\">{</span>        <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"name\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"johnDoe\"</span>        <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"age\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">age</span> <span class=\"o\">=</span> <span class=\"mi\">12</span>                <span class=\"nf\">init</span><span class=\"p\">()</span> <span class=\"p\">{}</span>    <span class=\"p\">}</span>        <span class=\"kd\">private</span> <span class=\"k\">let</span> <span class=\"nv\">storage</span> <span class=\"o\">=</span> <span class=\"kt\">Storage</span><span class=\"p\">()</span><span class=\"p\">}</span></code></pre></div></div><p>Finally the property observer <code class=\"language-plaintext highlighter-rouge\">didSet</code> is added for each variable we want to observe and update:</p><div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">import</span> <span class=\"kt\">SwiftUI</span><span class=\"kd\">@Observable</span> <span class=\"kd\">class</span> <span class=\"kt\">UserSettings</span> <span class=\"p\">{</span>    <span class=\"kd\">class</span> <span class=\"kt\">Storage</span> <span class=\"p\">{</span>        <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"name\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"johnDoe\"</span>        <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"age\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">age</span> <span class=\"o\">=</span> <span class=\"mi\">12</span>                <span class=\"nf\">init</span><span class=\"p\">()</span> <span class=\"p\">{}</span>    <span class=\"p\">}</span>        <span class=\"kd\">private</span> <span class=\"k\">let</span> <span class=\"nv\">storage</span> <span class=\"o\">=</span> <span class=\"kt\">Storage</span><span class=\"p\">()</span>        <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">name</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"p\">{</span>      <span class=\"k\">didSet</span> <span class=\"p\">{</span>        <span class=\"n\">storage</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>      <span class=\"p\">}</span>    <span class=\"p\">}</span>        <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"p\">{</span>      <span class=\"k\">didSet</span> <span class=\"p\">{</span>        <span class=\"n\">storage</span><span class=\"o\">.</span><span class=\"n\">age</span> <span class=\"o\">=</span> <span class=\"n\">age</span>      <span class=\"p\">}</span>    <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h4 id=\"code-breakdown\">Code Breakdown:</h4><p>Each property in <code class=\"language-plaintext highlighter-rouge\">UserSettings</code> is backed by a corresponding property in the <code class=\"language-plaintext highlighter-rouge\">Storage</code> class.</p><ul>  <li>    <p><strong>Direct Access and Persistence</strong>: when a property (e.g. <em>name</em>) in <code class=\"language-plaintext highlighter-rouge\">UserSettings</code> is set, its <code class=\"language-plaintext highlighter-rouge\">didSet</code> observe updates the corresponding value in the <code class=\"language-plaintext highlighter-rouge\">Storage</code> instance, which immediately saves it in <code class=\"language-plaintext highlighter-rouge\">UserDefaults</code> via the <code class=\"language-plaintext highlighter-rouge\">AppStorage</code> wrapper.</p>  </li>  <li>    <p><strong>Initialization and Synchronization</strong>: when <code class=\"language-plaintext highlighter-rouge\">UserSettings</code> is initialized, it sets its properties from the corresponding values in <code class=\"language-plaintext highlighter-rouge\">Stroage</code>, which reads these values from <code class=\"language-plaintext highlighter-rouge\">UserDefaults</code>. This ensures that a user’s settings are populated with the previously saved values when the app starts. With <code class=\"language-plaintext highlighter-rouge\">@AppStorage</code> properties encapsulated in a distinct reference type (<code class=\"language-plaintext highlighter-rouge\">Storage</code>), <code class=\"language-plaintext highlighter-rouge\">UserSettings</code> is able to indirectly access  <code class=\"language-plaintext highlighter-rouge\">@AppStorage</code> properties through <code class=\"language-plaintext highlighter-rouge\">Storage</code>, enabling observation via <code class=\"language-plaintext highlighter-rouge\">@Observable</code> while avoiding direct application of <code class=\"language-plaintext highlighter-rouge\">@AppStorage</code>.</p>  </li></ul><p>This approch effectively organizes data handling and observing changes in <code class=\"language-plaintext highlighter-rouge\">UserSettings</code> by leveraging the strengths of both <code class=\"language-plaintext highlighter-rouge\">@AppStorage</code> for persistent storage and <code class=\"language-plaintext highlighter-rouge\">@Observable</code> for observing and responding to changes.</p>",
            "url": "http://localhost:4000/2024/05/05/unpacking-observable-and-appstorage-part-2",
            
            
            
            "tags": ["swiftui","swift","observation","property wrappers","observable","appstorage"],
            
            "date_published": "2024-05-05T00:00:00-04:00",
            "date_modified": "2024-05-05T00:00:00-04:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2024/05/02/unpacking-observable-and-appstorage-part-1",
            "title": "@Observable vs @AppStorage Conflict: Part 1",
            "summary": "Explore the intricate relationship between @Observable and @AppStorage in SwiftUI in this detailed guide. Learn what triggers conflicts between these two features and gain insights into their operational mechanisms. Perfect for developers looking to deepen their understanding of SwiftUI's architecture and improve their coding practices",
            "content_text": "While working on the Onboarding feature of a SwiftUI application, my attempt to integrate the @Observable macro with the property wrapper @AppStorage resulted in an error. This article explores the reasons behind the error and provides insights into Swift property wrappers and their interaction with the @Observable macro.ProblemPreviously, the following ObservableObject pattern worked seamlessly:class Defaults: ObservableObject {\t@AppStorage(\"name\") public var name = \"johnDoe\"\t@AppStorage(\"age\") public var age = 12}var defaults = Defaults()Text(defaults.name)TextField(\"janeDoe\", text: defaults.$name)Migrating from ObservableObject to Observable with the following code:@Observable class DefaultsAsObservable {  @AppStorage(\"name\") public var name = \"fatbobman\"  @AppStorage(\"age\") public var age = 12}gives rise to the error message: Property wrapper cannot be applied to a computed property. To understand why this happens, we need to review how property wrappers interact with properties.Understanding Properties and Property AccessIn Swift, the characteristics and behaviors of the types class, struct and enumeration are modeled by properties.      Stored Properties    Stored properties encapsulate date directly and represent the most basic form of properties in Swift. For instance, the age, first name and last name of a person can be modeled by stored properties age, firstName, and lastName in a Person struct:      struct Person {    var age: Int = 0    var firstName: String = \"\"    var lastName: String = \"\"  }            Computed Properties    Computed properties do not store values directly. Instead, they compute their values on demand whenever they are accessed. Computed properties are particularly useful when a property value is derived from other data.    For example, to get the fullName of a person, we add computed property:      struct Person {    var age: Int = 0    var firstName: String = \"\"    var lastName: String = \"\"    var fullName: String {    \treturn \"\\(firstName) \\(_lastName)\"    }  }  //Example Usage:  let person = Person(firstName: \"John\", lastName: \"Doe\")  print(person.fullName) // Outputs: \"John Doe\"        The computed property fullName combines firstName and lastName each time it is accessed, providing a real-time, updated full name.        Getters and Setters    The ability to access properties are governed by getters and setters. Getters and setters are mechanisms for mediating access to properties, used both in stored and computed properties, where getters retrieve the value of a property while setters modify the value of a property before it is saved.    To illustrate how getters and setters work with stored properties, let’s ensure that age is never negative:      struct Person {    private var _age: Int = 0    var firstName: String = \"\" \t  var lastName: String = \"\"\t\t\t    var age: Int {    \tget { return _age }    \tset(newValue) { _age = max(0, newValue)} //ensure age is never negative    }    var fullName: String {    \treturn \"\\(firstName) \\(_lastName)\"    }            Note    the underscore prefix (_) differentiates the stored properties from their computed counterparts to avoid redeclaration errors.      Computed properties can also be declared with both a getter and a setter; thus allowing you to read (get) data from a property and write (set) date to a property:      struct Person {    private var _age: Int = 0    var firstName: String = \"\" \t  var lastName: String = \"\"\t\t\t    var age: Int {    \tget { return _age }\t  \t    \tset(newValue) { _age = max(0, newValue)}     }\t    var fullName: String {    \tget { \"\\(firstName) \\(_lastName)\" }    \tset {    \t\tlet nameComponents = newValue.split(separator: \" \")    \t\tif nameComponents.count == 2 {    \t\t\tfirstName = String(nameComponents[0])    \t\t\tlastName = String(nameComponents[1])    \t\t}    \t}    }\t  }        Encapsulating Property Behavior: Property WrappersProperty wrappers simplify repetitive patterns by encapsulating behaviors around properties. Below is an example that encapsulates the age restriction logic above in a property wrapper: import SwiftUI @propertyWrapper struct ClampedAge { \tprivate var value: Int \tprivate var range: ClosedRange&lt;Int&gt; = 0...125  \tvar wrappedValue: Int { \t\tget { return value } \t\tset { value = min(max(range.lowerBound, newValue), range.upperBound)} \t}  \tinit(wrappedValue: Int) {   \tself.value = min(max(range.lowerBound, wrappedValue), range.upperBound) \t} }      Wrapped Value    Property wrappers must expose a wrappedValue property. This property is used to represent the “value” being wrapped. When getting or setting a variable annotated with a property wrapper, the compiler automatically uses wrappedValue to get or set the value.    In the example above, @ClampedAge is used to enforce age validation based on a specified range via the method signature @ClampedAge var age: Int = 0 where:          the property being wrapped is age      the initial value of the property being wrapped is 0            Projected Value    In addition to wrappedValue, property wrappers can expose a projectedValue. This provides an additional way to interact with the wrapped property, offering more metadata or additional functionality.    In SwiftUI, property wrappers use projectedValue to offer a Binding to the wrapped property, enabling two-way data binding between views and the underlying data.    Example: Extending the previous example to include projectedValue as a Binding:      import SwiftUI  @propertyWrapper  struct ClampedAge {     private var value: Int     private var range: ClosedRange&lt;Int&gt; = 0...125\t     var wrappedValue: Int {       get { return value }       set { value = min(max(range.lowerBound, newValue), range.upperBound) }     }\t     var projectedValue: Binding&lt;Int&gt; {       Binding(         get: { self.wrappedValue },         set: { self.wrappedValue = $0 }       )     }\t     init(wrappedValue: Int) {       self.value = min(max(range.lowerBound, wrappedValue), range.upperBound)     }  }        Now, when a variable annotated with @ClampedAge is accessed with a dollar sign ($), the compiler will use projectedValue.    Example Usage:      import SwiftUI  struct Person {    @ClampedAge var age: Int = 0  }\t  struct ContentView: View {    @State private var person = Person()\t    var body: some View {    VStack {    \tText(\"Age: \\(person.age)\")    \tSlider(value: $person.$age, in: 0...125, step: 1)\t\t  .padding()    }  }        Applying @ClampedAge reduces the code used to implement struct Person:      import SwiftUI  struct Person {  \t@ClampedAge var age: Int = 0   \tvar firstName: String = \"\"  \tvar lastName: String = \"\"  }      Now that we understand how Property Wrappers work, lets turn our attention to their interaction with the @Observable macroObservation Framework: The BasicsIn iOS 17, Apple introduced the Observation framework to modernize the way SwiftUI and other frameworks handle state management. At the core of this framework is the Observable macro, which simplifies the process of making classes observable.Key Concepts of the Observation Framework      Observation Framework: includes a new Observable protocol, which:          extends Swift’s standard protocol for observation (Identifiable)      provides the mechanism to notify observers of changes            Observable macro: a macro that generate observation-related code that:          automatically transforms all stored properties in classes annotated with @Observable into computed properties with synthesized getters and setters      generates a mechanism for mutation tracking and change notification; when a property is modified the change is reported to observers using the synthesized observation mechanism.      @Observable’s Conflict with @AppStorage@AppStorage is a property wrapper designed to read/write values to UserDefaults with storage directly on the property. When a property is annotated with @AppStorage, the AppStorage property wrapper synthesizes its own getter and setter methods that handle that property’s interaction with UserDefaults.Since @Observable macro works at class level, synthesizing getters and setters for all properties within the class, and @AppStorage property wrapper works directly on the stored property level, attempting to use both together leads to a conflict:\t@Observable: synthesizes computed properties for all annotated properties in the class\t@AppStorage: attempts to override these properties with its own property wrapper mechanismThe combination of @Observable and @AppStorage is not directly supported due to conflicting property access patterns. In a follow up article, I discuss how to overcome this conflict.",
            "content_html": "<p>While working on the <strong>Onboarding</strong> feature of a SwiftUI application, my attempt to integrate the <a href=\"https://developer.apple.com/documentation/Observation/Observable()\">@Observable macro</a> with the property wrapper <a href=\"https://developer.apple.com/documentation/swiftui/appstorage\">@AppStorage</a> resulted in an error. This article explores the reasons behind the error and provides insights into Swift property wrappers and their interaction with the @Observable macro.</p><h2 id=\"problem\"><u>Problem</u></h2><p>Previously, the following <a href=\"https://developer.apple.com/documentation/combine/observableobject\">ObservableObject</a> pattern worked seamlessly:</p><div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">Defaults</span><span class=\"p\">:</span> <span class=\"kt\">ObservableObject</span> <span class=\"p\">{</span>\t<span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"name\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"johnDoe\"</span>\t<span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"age\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">age</span> <span class=\"o\">=</span> <span class=\"mi\">12</span><span class=\"p\">}</span><span class=\"k\">var</span> <span class=\"nv\">defaults</span> <span class=\"o\">=</span> <span class=\"kt\">Defaults</span><span class=\"p\">()</span><span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"n\">defaults</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">)</span><span class=\"kt\">TextField</span><span class=\"p\">(</span><span class=\"s\">\"janeDoe\"</span><span class=\"p\">,</span> <span class=\"nv\">text</span><span class=\"p\">:</span> <span class=\"n\">defaults</span><span class=\"o\">.</span><span class=\"n\">$name</span><span class=\"p\">)</span></code></pre></div></div><p>Migrating from <strong>ObservableObject</strong> to <strong>Observable</strong> with the following code:</p><div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">@Observable</span> <span class=\"kd\">class</span> <span class=\"kt\">DefaultsAsObservable</span> <span class=\"p\">{</span>  <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"name\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">name</span> <span class=\"o\">=</span> <span class=\"s\">\"fatbobman\"</span>  <span class=\"kd\">@AppStorage</span><span class=\"p\">(</span><span class=\"s\">\"age\"</span><span class=\"p\">)</span> <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">age</span> <span class=\"o\">=</span> <span class=\"mi\">12</span><span class=\"p\">}</span></code></pre></div></div><p>gives rise to the error message: <code class=\"language-plaintext highlighter-rouge\">Property wrapper cannot be applied to a computed property</code>. To understand why this happens, we need to review how property wrappers interact with properties.</p><h2 id=\"understanding-properties-and-property-access\"><u>Understanding Properties and Property Access</u></h2><p>In Swift, the characteristics and behaviors of the types <strong>class</strong>, <strong>struct</strong> and <strong>enumeration</strong> are modeled by properties.</p><ul>  <li>    <p><strong>Stored Properties</strong></p>    <p>Stored properties encapsulate date directly and represent the most basic form of properties in Swift. For instance, the age, first name and last name of a person can be modeled by stored properties <em>age</em>, <em>firstName</em>, and <em>lastName</em> in a <strong>Person struct</strong>:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">struct</span> <span class=\"kt\">Person</span> <span class=\"p\">{</span>    <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"k\">var</span> <span class=\"nv\">firstName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>    <span class=\"k\">var</span> <span class=\"nv\">lastName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>  <span class=\"p\">}</span></code></pre></div>    </div>  </li>  <li>    <p><strong>Computed Properties</strong></p>    <p>Computed properties do not store values directly. Instead, they compute their values on demand whenever they are accessed. Computed properties are particularly useful when a property value is derived from other data.</p>    <p>For example, to get the <em>fullName</em> of a person, we add computed property:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">struct</span> <span class=\"kt\">Person</span> <span class=\"p\">{</span>    <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"k\">var</span> <span class=\"nv\">firstName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>    <span class=\"k\">var</span> <span class=\"nv\">lastName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>    <span class=\"k\">var</span> <span class=\"nv\">fullName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"p\">{</span>    \t<span class=\"k\">return</span> <span class=\"s\">\"</span><span class=\"se\">\\(</span><span class=\"n\">firstName</span><span class=\"se\">)</span><span class=\"s\"> </span><span class=\"se\">\\(</span><span class=\"n\">_lastName</span><span class=\"se\">)</span><span class=\"s\">\"</span>    <span class=\"p\">}</span>  <span class=\"p\">}</span>  <span class=\"c1\">//Example Usage:</span>  <span class=\"k\">let</span> <span class=\"nv\">person</span> <span class=\"o\">=</span> <span class=\"kt\">Person</span><span class=\"p\">(</span><span class=\"nv\">firstName</span><span class=\"p\">:</span> <span class=\"s\">\"John\"</span><span class=\"p\">,</span> <span class=\"nv\">lastName</span><span class=\"p\">:</span> <span class=\"s\">\"Doe\"</span><span class=\"p\">)</span>  <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"n\">person</span><span class=\"o\">.</span><span class=\"n\">fullName</span><span class=\"p\">)</span> <span class=\"c1\">// Outputs: \"John Doe\"</span></code></pre></div>    </div>    <p>The computed property <strong><code class=\"language-plaintext highlighter-rouge\">fullName</code></strong> combines <em>firstName</em> and <em>lastName</em> each time it is accessed, providing a real-time, updated full name.</p>  </li>  <li>    <p><strong>Getters and Setters</strong></p>    <p>The ability to access properties are governed by <strong>getters and setters</strong>. Getters and setters are mechanisms for mediating access to properties, used both in stored and computed properties, where getters retrieve the value of a property while setters modify the value of a property before it is saved.</p>    <p>To illustrate how getters and setters work with stored properties, let’s ensure that age is never negative:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">struct</span> <span class=\"kt\">Person</span> <span class=\"p\">{</span>    <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">_age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"k\">var</span> <span class=\"nv\">firstName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span> \t  <span class=\"k\">var</span> <span class=\"nv\">lastName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>\t\t\t    <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"p\">{</span>    \t<span class=\"k\">get</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">_age</span> <span class=\"p\">}</span>    \t<span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"n\">newValue</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">_age</span> <span class=\"o\">=</span> <span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">newValue</span><span class=\"p\">)}</span> <span class=\"c1\">//ensure age is never negative</span>    <span class=\"p\">}</span>    <span class=\"k\">var</span> <span class=\"nv\">fullName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"p\">{</span>    \t<span class=\"k\">return</span> <span class=\"s\">\"</span><span class=\"se\">\\(</span><span class=\"n\">firstName</span><span class=\"se\">)</span><span class=\"s\"> </span><span class=\"se\">\\(</span><span class=\"n\">_lastName</span><span class=\"se\">)</span><span class=\"s\">\"</span>    <span class=\"p\">}</span></code></pre></div>    </div>    <details>    <summary>Note</summary>    the underscore prefix (_) differentiates the stored properties from their computed counterparts to avoid redeclaration errors.  </details>    <p>Computed properties can also be declared with both a getter and a setter; thus allowing you to read (get) data from a property and write (set) date to a property:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">struct</span> <span class=\"kt\">Person</span> <span class=\"p\">{</span>    <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">_age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"k\">var</span> <span class=\"nv\">firstName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span> \t  <span class=\"k\">var</span> <span class=\"nv\">lastName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>\t\t\t    <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"p\">{</span>    \t<span class=\"k\">get</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">_age</span> <span class=\"p\">}</span>\t  \t    \t<span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"n\">newValue</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">_age</span> <span class=\"o\">=</span> <span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">newValue</span><span class=\"p\">)}</span>     <span class=\"p\">}</span>\t    <span class=\"k\">var</span> <span class=\"nv\">fullName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"p\">{</span>    \t<span class=\"k\">get</span> <span class=\"p\">{</span> <span class=\"s\">\"</span><span class=\"se\">\\(</span><span class=\"n\">firstName</span><span class=\"se\">)</span><span class=\"s\"> </span><span class=\"se\">\\(</span><span class=\"n\">_lastName</span><span class=\"se\">)</span><span class=\"s\">\"</span> <span class=\"p\">}</span>    \t<span class=\"k\">set</span> <span class=\"p\">{</span>    \t\t<span class=\"k\">let</span> <span class=\"nv\">nameComponents</span> <span class=\"o\">=</span> <span class=\"n\">newValue</span><span class=\"o\">.</span><span class=\"nf\">split</span><span class=\"p\">(</span><span class=\"nv\">separator</span><span class=\"p\">:</span> <span class=\"s\">\" \"</span><span class=\"p\">)</span>    \t\t<span class=\"k\">if</span> <span class=\"n\">nameComponents</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"p\">{</span>    \t\t\t<span class=\"n\">firstName</span> <span class=\"o\">=</span> <span class=\"kt\">String</span><span class=\"p\">(</span><span class=\"n\">nameComponents</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>    \t\t\t<span class=\"n\">lastName</span> <span class=\"o\">=</span> <span class=\"kt\">String</span><span class=\"p\">(</span><span class=\"n\">nameComponents</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>    \t\t<span class=\"p\">}</span>    \t<span class=\"p\">}</span>    <span class=\"p\">}</span>\t  <span class=\"p\">}</span>  </code></pre></div>    </div>  </li></ul><h2 id=\"encapsulating-property-behavior-property-wrappers\"><u>Encapsulating Property Behavior: Property Wrappers</u></h2><p>Property wrappers simplify repetitive patterns by encapsulating behaviors around properties. Below is an example that encapsulates the age restriction logic above in a property wrapper:</p><div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"kd\">import</span> <span class=\"kt\">SwiftUI</span> <span class=\"kd\">@propertyWrapper</span> <span class=\"kd\">struct</span> <span class=\"kt\">ClampedAge</span> <span class=\"p\">{</span> \t<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> \t<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">range</span><span class=\"p\">:</span> <span class=\"kt\">ClosedRange</span><span class=\"o\">&lt;</span><span class=\"kt\">Int</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">...</span><span class=\"mi\">125</span>  \t<span class=\"k\">var</span> <span class=\"nv\">wrappedValue</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"p\">{</span> \t\t<span class=\"k\">get</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">value</span> <span class=\"p\">}</span> \t\t<span class=\"k\">set</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nf\">min</span><span class=\"p\">(</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">lowerBound</span><span class=\"p\">,</span> <span class=\"n\">newValue</span><span class=\"p\">),</span> <span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">upperBound</span><span class=\"p\">)}</span> \t<span class=\"p\">}</span>  \t<span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"nv\">wrappedValue</span><span class=\"p\">:</span> <span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"p\">{</span>   \t<span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nf\">min</span><span class=\"p\">(</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">lowerBound</span><span class=\"p\">,</span> <span class=\"n\">wrappedValue</span><span class=\"p\">),</span> <span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">upperBound</span><span class=\"p\">)</span> \t<span class=\"p\">}</span> <span class=\"p\">}</span></code></pre></div></div><ul>  <li>    <p><strong>Wrapped Value</strong></p>    <p>Property wrappers must expose a <a href=\"https://developer.apple.com/documentation/swiftui/binding/wrappedvalue\">wrappedValue</a> property. This property is used to represent the <strong>“value”</strong> being wrapped. When getting or setting a variable annotated with a property wrapper, the compiler automatically uses <code class=\"language-plaintext highlighter-rouge\">wrappedValue</code> to get or set the value.</p>    <p>In the example above, <strong>@ClampedAge</strong> is used to enforce age validation based on a specified range via the method signature <strong>@ClampedAge var age: Int = 0</strong> where:</p>    <ul>      <li>the property being wrapped is <code class=\"language-plaintext highlighter-rouge\">age</code></li>      <li>the initial value of the property being wrapped is 0</li>    </ul>  </li>  <li>    <p><strong>Projected Value</strong></p>    <p>In addition to <strong><em>wrappedValue</em></strong>, property wrappers can expose a <strong><em>projectedValue</em></strong>. This provides an additional way to interact with the wrapped property, offering more metadata or additional functionality.</p>    <p>In SwiftUI, property wrappers use projectedValue to offer a <a href=\"https://developer.apple.com/documentation/swiftui/binding\">Binding</a> to the wrapped property, enabling two-way data binding between views and the underlying data.</p>    <p><strong>Example</strong>: Extending the previous example to include projectedValue as a Binding:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">import</span> <span class=\"kt\">SwiftUI</span>  <span class=\"kd\">@propertyWrapper</span>  <span class=\"kd\">struct</span> <span class=\"kt\">ClampedAge</span> <span class=\"p\">{</span>     <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">Int</span>     <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">range</span><span class=\"p\">:</span> <span class=\"kt\">ClosedRange</span><span class=\"o\">&lt;</span><span class=\"kt\">Int</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">...</span><span class=\"mi\">125</span>\t     <span class=\"k\">var</span> <span class=\"nv\">wrappedValue</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"p\">{</span>       <span class=\"k\">get</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">value</span> <span class=\"p\">}</span>       <span class=\"k\">set</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nf\">min</span><span class=\"p\">(</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">lowerBound</span><span class=\"p\">,</span> <span class=\"n\">newValue</span><span class=\"p\">),</span> <span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">upperBound</span><span class=\"p\">)</span> <span class=\"p\">}</span>     <span class=\"p\">}</span>\t     <span class=\"k\">var</span> <span class=\"nv\">projectedValue</span><span class=\"p\">:</span> <span class=\"kt\">Binding</span><span class=\"o\">&lt;</span><span class=\"kt\">Int</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>       <span class=\"kt\">Binding</span><span class=\"p\">(</span>         <span class=\"nv\">get</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">wrappedValue</span> <span class=\"p\">},</span>         <span class=\"nv\">set</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">wrappedValue</span> <span class=\"o\">=</span> <span class=\"nv\">$0</span> <span class=\"p\">}</span>       <span class=\"p\">)</span>     <span class=\"p\">}</span>\t     <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"nv\">wrappedValue</span><span class=\"p\">:</span> <span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"p\">{</span>       <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nf\">min</span><span class=\"p\">(</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">lowerBound</span><span class=\"p\">,</span> <span class=\"n\">wrappedValue</span><span class=\"p\">),</span> <span class=\"n\">range</span><span class=\"o\">.</span><span class=\"n\">upperBound</span><span class=\"p\">)</span>     <span class=\"p\">}</span>  <span class=\"p\">}</span></code></pre></div>    </div>    <p>Now, when a variable annotated with <strong>@ClampedAge</strong> is accessed with a dollar sign (<strong>$</strong>), the compiler will use projectedValue.</p>    <p><strong>Example Usage</strong>:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">import</span> <span class=\"kt\">SwiftUI</span>  <span class=\"kd\">struct</span> <span class=\"kt\">Person</span> <span class=\"p\">{</span>    <span class=\"kd\">@ClampedAge</span> <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>  <span class=\"p\">}</span>\t  <span class=\"kd\">struct</span> <span class=\"kt\">ContentView</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>    <span class=\"kd\">@State</span> <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">person</span> <span class=\"o\">=</span> <span class=\"kt\">Person</span><span class=\"p\">()</span>\t    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"kd\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>    <span class=\"kt\">VStack</span> <span class=\"p\">{</span>    \t<span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Age: </span><span class=\"se\">\\(</span><span class=\"n\">person</span><span class=\"o\">.</span><span class=\"n\">age</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>    \t<span class=\"kt\">Slider</span><span class=\"p\">(</span><span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"n\">$person</span><span class=\"o\">.</span><span class=\"n\">$age</span><span class=\"p\">,</span> <span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"o\">...</span><span class=\"mi\">125</span><span class=\"p\">,</span> <span class=\"nv\">step</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\t\t  <span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">()</span>    <span class=\"p\">}</span>  <span class=\"p\">}</span></code></pre></div>    </div>    <p>Applying <strong>@ClampedAge</strong> reduces the code used to implement struct <code class=\"language-plaintext highlighter-rouge\">Person</code>:</p>    <div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"kd\">import</span> <span class=\"kt\">SwiftUI</span>  <span class=\"kd\">struct</span> <span class=\"kt\">Person</span> <span class=\"p\">{</span>  \t<span class=\"kd\">@ClampedAge</span> <span class=\"k\">var</span> <span class=\"nv\">age</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>   \t<span class=\"k\">var</span> <span class=\"nv\">firstName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>  \t<span class=\"k\">var</span> <span class=\"nv\">lastName</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span>  <span class=\"p\">}</span></code></pre></div>    </div>  </li></ul><p>Now that we understand how <em>Property Wrappers</em> work, lets turn our attention to their interaction with the <strong>@Observable macro</strong></p><h2 id=\"observation-framework-the-basics\"><u>Observation Framework: The Basics</u></h2><p>In iOS 17, Apple introduced the <a href=\"https://developer.apple.com/documentation/observation\">Observation framework</a> to modernize the way SwiftUI and other frameworks handle state management. At the core of this framework is the <a href=\"https://developer.apple.com/documentation/observation/observable()\">Observable macro</a>, which simplifies the process of making classes observable.</p><p><u>Key Concepts of the Observation Framework</u></p><ul>  <li>    <p><strong>Observation Framework</strong>: includes a new Observable protocol, which:</p>    <ul>      <li>extends Swift’s standard protocol for observation (Identifiable)</li>      <li>provides the mechanism to notify observers of changes</li>    </ul>  </li>  <li>    <p><strong>Observable macro</strong>: a macro that generate observation-related code that:</p>    <ul>      <li>automatically transforms all stored properties in classes annotated with <strong>@Observable</strong> into computed properties with synthesized getters and setters</li>      <li>generates a mechanism for mutation tracking and change notification; when a property is modified the change is reported to observers using the synthesized observation mechanism.</li>    </ul>  </li></ul><h2 id=\"observables-conflict-with-appstorage\"><u>@Observable’s Conflict with @AppStorage</u></h2><p><strong>@AppStorage</strong> is a property wrapper designed to read/write values to UserDefaults with storage directly on the property. When a property is annotated with <strong>@AppStorage</strong>, the AppStorage property wrapper synthesizes its own getter and setter methods that handle that property’s interaction with UserDefaults.</p><p>Since <strong>@Observable macro</strong> works at class level, synthesizing getters and setters for all properties within the class, and <strong>@AppStorage property wrapper</strong> works directly on the stored property level, attempting to use both together leads to a conflict:</p><ul class=\"nested\">\t<li><b>@Observable</b>: synthesizes computed properties for all annotated properties in the class</li>\t<li><b>@AppStorage</b>: attempts to override these properties with its own property wrapper mechanism</li></ul><p>The combination of <strong>@Observable</strong> and <strong>@AppStorage</strong> is not directly supported due to conflicting property access patterns. In a follow up article, I discuss how to overcome this conflict.</p>",
            "url": "http://localhost:4000/2024/05/02/unpacking-observable-and-appstorage-part-1",
            
            
            
            "tags": ["swiftui","swift","observation","property wrappers","observable","appstorage"],
            
            "date_published": "2024-05-02T00:00:00-04:00",
            "date_modified": "2024-05-02T00:00:00-04:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2021/10/31/terraform-operational-vs-provisioned-resources",
            "title": "TF: Operational vs Provisioned Resources",
            "summary": "getting started with Terraform correctly",
            "content_text": "“Hello, World!” documentations are notorious for their deceptive marketing. Terraform is no exception1 as its getting started guide hides the complexity of setting up, managing, and sharing terraform state in a secure and collaborative managing manner with team members.It took a while but I have finally figured out that it is best to separate the creation of the backend infrastructure needed to run terraform at scale successfully - henceforth referred to as “operational resources” - from the infrastructure provisioned and managed by Terraform.When working with AWS2, I use Cloudformation to create Terraform’s operational resources. Additionally, whenever you can, I advocate holding all your Terraform operational resourcs in a separate AWS.Here is a template, heavily influenced by Chris Kent work. This template assumes the existence of a separate AWS account dedicated solely to holding Terraform operational resources but it can be edited to work with a single AWS accountFootnotes            To be fair, consider Terraform Cloud if you don’t mind paying for yet another Iac solution &#8617;              For GoogleCloud, I use Deployment Manager. Template coming soon &#8617;      ",
            "content_html": "<p>“Hello, World!” documentations are notorious for their deceptive marketing. Terraform is no exception<sup id=\"fnref:1\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup> as its <em>getting started</em> guide hides the complexity of setting up, managing, and sharing <a href=\"https://www.terraform.io/language/state\">terraform state</a> in a secure and collaborative managing manner with team members.</p><p>It took a while but I have finally figured out that it is best to separate the creation of the backend infrastructure needed to run terraform at scale successfully - henceforth referred to as “operational resources” - from the infrastructure provisioned and managed by Terraform.</p><p>When working with AWS<sup id=\"fnref:2\" role=\"doc-noteref\"><a href=\"#fn:2\" class=\"footnote\" rel=\"footnote\">2</a></sup>, I use <a href=\"https://aws.amazon.com/cloudformation/\">Cloudformation</a> to create Terraform’s operational resources. Additionally, whenever you can, I advocate holding all your Terraform operational resourcs in a separate AWS.</p><p><a href=\"https://github.com/msuzoagu/cloudformation_template_for_terraform_operational_resources\">Here</a> is a template, heavily influenced by <a href=\"https://thirstydeveloper.io/series/tf-skeleton.html\">Chris Kent</a> work. This template assumes the existence of a separate AWS account dedicated solely to holding Terraform operational resources but it can be edited to work with a single AWS account</p><h5 id=\"footnotes\">Footnotes</h5><div class=\"footnotes\" role=\"doc-endnotes\">  <ol>    <li id=\"fn:1\" role=\"doc-endnote\">      <p>To be fair, consider <a href=\"https://www.hashicorp.com/resources/what-is-terraform-cloud\">Terraform Cloud</a> if you don’t mind paying for yet another Iac solution <a href=\"#fnref:1\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a></p>    </li>    <li id=\"fn:2\" role=\"doc-endnote\">      <p>For GoogleCloud, I use <a href=\"https://cloud.google.com/deployment-manager/docs\">Deployment Manager</a>. Template coming soon <a href=\"#fnref:2\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a></p>    </li>  </ol></div>",
            "url": "http://localhost:4000/2021/10/31/terraform-operational-vs-provisioned-resources",
            
            
            
            "tags": ["aws","google-cloud","terraform","cloudformation","devops"],
            
            "date_published": "2021-10-31T00:00:00-04:00",
            "date_modified": "2021-10-31T00:00:00-04:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2019/12/20/customized-page-indicators-for-uipageviewcontroller",
            "title": "UIPageViewController: Customizing Page Indicators",
            "summary": "customize page indicator in UIPageViewController",
            "content_text": "Having not worked on an iOS project in a long while, I was stumped recently when I had to customize the page indicator for an onboarding screen.I tend to build my views programatically but documentation for UIPageViewController does not provide information on how to programatically access the default page indication built into UIPageViewController. My guess, after trying different methods on my instance of UIPageViewController and having my google-fu fail me, is that there isn’t a way to programatically access the default page indicator.The solution I implemented relies on both presentationCount and presentationIndex. According to Apple’s documentation a page indicator is visible under these conditions only: \t- if both presentationCount and presentationIndex are implemented\t- if the transitionStyle is scroll \t- and if the navigation orientation is horizontal.As of iOS 16, the minimal code to accomplish this:import UIKitclass OnboardingViewController: UIViewController {  private var currentIndex: Int = 0  private var pageController: UIPageViewController?  override func viewDidLoad() {    super.viewDidLoad()    self.setupPageController()  }  private func setupPageController() {    self.pageController = UIPageViewController(      transitionStyle: .scroll, navigationOrientation: .horizontal)    self.pageController?.delegate = self    self.pageController?.dataSource = self    self.pageController?.view.backgroundColor = .systemRed  }  private func customizePageIndicator() {    let appearance = UIPageControl.appearance()    appearance.pageIndicatorTintColor = .systemGray    appearance.currentPageIndicatorTintColor = .white    appearance.backgroundColor = .systemRed  }  func presentationCount(for pageViewController: UIPageViewController) -&gt; Int {    self.customizePageIndicator()    return self.onboardingContent.count  }  func presentationIndex(for pageViewController: UIPageViewController) -&gt; Int {    return self.currentIndex  }}extension OnboardingViewController: UIPageViewControllerDataSource {  func pageViewController(    _ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController  ) -&gt; UIViewController? {    // implement logic that displays next vc when user swipes to next screen  }  func pageViewController(    _ pageViewController: UIPageViewController,    viewControllerBefore viewController: UIViewController  ) -&gt; UIViewController? {    //implement logic that displays previous viewController    // basically what to display when user swips back to previous screen  }}     note: I am using the regular ViewController as the container of the PageViewController; you don’t have to do it this way.It feels counter-intutive to implement a new UIPageControl instead of using what is baked into the UIPageViewController; will have to investigate when time permits.",
            "content_html": "<p>Having not worked on an iOS project in a long while, I was stumped recently when I had to customize the page indicator for an onboarding screen.</p><p>I tend to build my views programatically but documentation for UIPageViewController does not provide information on how to programatically access the default page indication built into UIPageViewController. My guess, after trying different methods on my instance of UIPageViewController and having my google-fu fail me, is that there isn’t a way to programatically access the default page indicator.</p><p>The solution I implemented relies on both <code class=\"language-plaintext highlighter-rouge\">presentationCount</code> and <code class=\"language-plaintext highlighter-rouge\">presentationIndex</code>. According to Apple’s documentation a page indicator is visible under these conditions only: \t- if both <code class=\"language-plaintext highlighter-rouge\">presentationCount</code> and <code class=\"language-plaintext highlighter-rouge\">presentationIndex</code> are implemented\t- if the transitionStyle is scroll \t- and if the navigation orientation is horizontal.</p><p>As of iOS 16, the minimal code to accomplish this:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import UIKitclass OnboardingViewController: UIViewController {  private var currentIndex: Int = 0  private var pageController: UIPageViewController?  override func viewDidLoad() {    super.viewDidLoad()    self.setupPageController()  }  private func setupPageController() {    self.pageController = UIPageViewController(      transitionStyle: .scroll, navigationOrientation: .horizontal)    self.pageController?.delegate = self    self.pageController?.dataSource = self    self.pageController?.view.backgroundColor = .systemRed  }  private func customizePageIndicator() {    let appearance = UIPageControl.appearance()    appearance.pageIndicatorTintColor = .systemGray    appearance.currentPageIndicatorTintColor = .white    appearance.backgroundColor = .systemRed  }  func presentationCount(for pageViewController: UIPageViewController) -&gt; Int {    self.customizePageIndicator()    return self.onboardingContent.count  }  func presentationIndex(for pageViewController: UIPageViewController) -&gt; Int {    return self.currentIndex  }}extension OnboardingViewController: UIPageViewControllerDataSource {  func pageViewController(    _ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController  ) -&gt; UIViewController? {    // implement logic that displays next vc when user swipes to next screen  }  func pageViewController(    _ pageViewController: UIPageViewController,    viewControllerBefore viewController: UIViewController  ) -&gt; UIViewController? {    //implement logic that displays previous viewController    // basically what to display when user swips back to previous screen  }}     </code></pre></div></div><p><strong>note</strong>: I am using the regular ViewController as the container of the PageViewController; you don’t have to do it this way.</p><p>It feels counter-intutive to implement a new UIPageControl instead of using what is baked into the UIPageViewController; will have to investigate when time permits.</p>",
            "url": "http://localhost:4000/2019/12/20/customized-page-indicators-for-uipageviewcontroller",
            
            
            
            "tags": ["swift","uikit"],
            
            "date_published": "2019-12-20T00:00:00-05:00",
            "date_modified": "2019-12-20T00:00:00-05:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2014/04/07/git-changelog-pre-push-hook",
            "title": "A Simple Git Pre-Push Hook",
            "summary": "pre-push hook to check for changelog updates",
            "content_text": "On my personal projects, the script below reminds me to update my changelog:#!/bin/shexec &lt; /dev/ttywhile true; do  read -p \"Have you updated the changelog? (y/n) \" response   if [[ \"$response\" ==  \"y\" ]] || [[ \"$response\" == \"Y\" ]]; then    exit 0  else     echo &gt;&amp;2 \"run '$ codelog new &lt;NAME&gt;' to record changes made\"     exit 1  fidoneScript is placed in hooks subdirectory of the Git directory (project_dir/.git/.hooks).",
            "content_html": "<p>On my personal projects, the script below reminds me to update my changelog:</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">#!/bin/sh</span><span class=\"nb\">exec</span> &lt; /dev/tty<span class=\"k\">while </span><span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"k\">do  </span><span class=\"nb\">read</span> <span class=\"nt\">-p</span> <span class=\"s2\">\"Have you updated the changelog? (y/n) \"</span> response   <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"s2\">\"</span><span class=\"nv\">$response</span><span class=\"s2\">\"</span> <span class=\"o\">==</span>  <span class=\"s2\">\"y\"</span> <span class=\"o\">]]</span> <span class=\"o\">||</span> <span class=\"o\">[[</span> <span class=\"s2\">\"</span><span class=\"nv\">$response</span><span class=\"s2\">\"</span> <span class=\"o\">==</span> <span class=\"s2\">\"Y\"</span> <span class=\"o\">]]</span><span class=\"p\">;</span> <span class=\"k\">then    </span><span class=\"nb\">exit </span>0  <span class=\"k\">else     </span><span class=\"nb\">echo</span> <span class=\"o\">&gt;</span>&amp;2 <span class=\"s2\">\"run '</span><span class=\"nv\">$ </span><span class=\"s2\">codelog new &lt;NAME&gt;' to record changes made\"</span>     <span class=\"nb\">exit </span>1  <span class=\"k\">fidone</span></code></pre></div></div><p>Script is placed in hooks subdirectory of the Git directory (<strong>project_dir/.git/.hooks</strong>).</p>",
            "url": "http://localhost:4000/2014/04/07/git-changelog-pre-push-hook",
            
            
            
            
            
            "date_published": "2014-04-07T00:00:00-04:00",
            "date_modified": "2014-04-07T00:00:00-04:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}